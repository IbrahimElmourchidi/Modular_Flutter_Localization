import * as fs from 'fs';
import * as path from 'path';
import { ParsedModule, TranslationKey } from './arb_parser';
import { ArbParser } from './arb_parser';

export interface GeneratorConfig {
    outputPath: string;
    className: string;
    defaultLocale: string;
    supportedLocales: string[];
    generateCombinedArb: boolean;
}

export class DartGenerator {
    constructor(private config: GeneratorConfig) { }

    async generate(modules: ParsedModule[]): Promise<void> {
        // Ensure output directory exists
        fs.mkdirSync(this.config.outputPath, { recursive: true });

        // Generate main S class
        await this.generateMainClass(modules);

        // Generate module classes
        for (const module of modules) {
            await this.generateModuleClass(module);
        }

        // Generate delegate
        await this.generateDelegate(modules);

        // Generate messages files for each locale
        await this.generateMessagesFiles(modules);

        // Generate combined ARB files if enabled
        if (this.config.generateCombinedArb) {
            await this.generateCombinedArbFiles(modules);
        }

        // Generate barrel file
        await this.generateBarrelFile(modules);
    }

    private async generateMainClass(modules: ParsedModule[]): Promise<void> {
        const moduleImports = modules
            .map((m) => `import '${this.toSnakeCase(m.name)}_l10n.dart';`)
            .join('\n');

        const moduleGetters = modules
            .map((m) => {
                const className = this.toPascalCase(m.name) + 'L10n';
                const fieldName = this.toCamelCase(m.name);
                return `  static ${className} get ${fieldName} => _${fieldName}!;
static ${className}? _${fieldName};`;
            })
            .join('\n');

        const moduleLoaders = modules
            .map((m) => {
                const className = this.toPascalCase(m.name) + 'L10n';
                const fieldName = this.toCamelCase(m.name);
                return `    _${fieldName} = ${className}.load(localeName);`;
            })
            .join('\n');

        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
import './app_localization_delegate.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';
${moduleImports}

/// Main localization class providing access to all module translations.
///
/// Usage:
/// \`\`\`dart
/// // Access translations
/// Text(${this.config.className}.auth.email)
/// Text(${this.config.className}.home.welcomeMessage)
/// \`\`\`
class ${this.config.className} {
${this.config.className}._();
static ${this.config.className}? _current;
static ${this.config.className} get current {
assert(
_current != null,
'No instance of ${this.config.className} was loaded. '
'Try to initialize the ${this.config.className} delegate before accessing ${this.config.className}.current.',
);
return _current!;
}

${moduleGetters}

static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

static Future<${this.config.className}> load(Locale locale) async {
final name = (locale.countryCode?.isEmpty ?? false)
? locale.languageCode
: locale.toString();
final localeName = Intl.canonicalizedLocale(name);
Intl.defaultLocale = localeName;

// Register message lookup tables for the locale
await initializeMessages(localeName);

final instance = ${this.config.className}._();
${this.config.className}._current = instance;

// Load all module translations
${moduleLoaders}

return instance;
}

static ${this.config.className} of(BuildContext context) {
final instance = ${this.config.className}.maybeOf(context);
assert(
instance != null,
'No instance of ${this.config.className} present in the widget tree. '
'Did you add ${this.config.className}.delegate in localizationsDelegates?',
);
return instance!;
}

static ${this.config.className}? maybeOf(BuildContext context) {
return Localizations.of<${this.config.className}>(context, ${this.config.className});
}

/// List of all supported locales
static const List<Locale> supportedLocales = [
${this.config.supportedLocales.map((l) => `    Locale('${l}'),`).join('\n')}
];
}
`;

        const filePath = path.join(
            this.config.outputPath,
            `${this.toSnakeCase(this.config.className)}.dart`
        );
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private async generateModuleClass(module: ParsedModule[]): Promise<void>;
    private async generateModuleClass(module: ParsedModule): Promise<void>;
    private async generateModuleClass(module: ParsedModule | ParsedModule[]): Promise<void> {
        if (Array.isArray(module)) {
            // Handle array case if needed (not used in current logic)
            return;
        }

        const className = this.toPascalCase(module.name) + 'L10n';
        const messagesClassName = this.toPascalCase(module.name) + 'Messages';

        const methods = module.keys
            .map((key) => this.generateMethod(key, module.name))
            .join('\n');

        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
// Module: ${module.name}
import 'package:intl/intl.dart';

/// Localization class for the ${module.name} module.
class ${className} {
${className}._();
static ${className}? _instance;
static ${className} load(String localeName) {
_instance = ${className}._();
return _instance!;
}
static ${className} get instance {
assert(_instance != null, '${className} not loaded');
return _instance!;
}

${methods}
}
`;

        const filePath = path.join(
            this.config.outputPath,
            `${this.toSnakeCase(module.name)}_l10n.dart`
        );
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private generateMethod(key: TranslationKey, moduleName: string): string {
        const defaultTranslation = key.translations[this.config.defaultLocale] || '';
        const placeholders = ArbParser.extractPlaceholders(defaultTranslation);
        const hasIcuSyntax = ArbParser.hasIcuSyntax(defaultTranslation);
        const description = key.description || defaultTranslation;
        const escapedDescription = description.replace(/`/g, "'").replace(/\n/g, ' ');

        // 1. Handle ICU Plural Syntax
        if (hasIcuSyntax && defaultTranslation.includes('plural')) {
            // We look for the main variable name in ICU (e.g., 'count' from {count, plural, ...})
            const icuVarMatch = defaultTranslation.match(/\{(\w+),\s*plural/);
            const icuVar = icuVarMatch ? icuVarMatch[1] : 'count';

            return `  /// \`${escapedDescription}\`
String ${key.key}(int ${icuVar}) {
return Intl.plural(
${icuVar},
zero: '${this.extractPluralPart(defaultTranslation, '=0')}',
one: '${this.extractPluralPart(defaultTranslation, '=1')}',
two: '${this.extractPluralPart(defaultTranslation, '=2')}',
few: '${this.extractPluralPart(defaultTranslation, 'few')}',
many: '${this.extractPluralPart(defaultTranslation, 'many')}',
other: '${this.extractPluralPart(defaultTranslation, 'other')}',
name: '${moduleName}_${key.key}',
desc: '${this.escapeDartString(key.description || '')}',
args: [${icuVar}],
);
}`;
        }

        // 2. Handle standard methods with parameters
        if (placeholders.length > 0) {
            const params = placeholders
                .map((p) => `${this.getPlaceholderType(key, p)} ${p}`)
                .join(', ');

            return `  /// \`${escapedDescription}\`
String ${key.key}(${params}) {
return Intl.message(
'${this.escapeDartString(defaultTranslation)}',
name: '${moduleName}_${key.key}',
desc: '${this.escapeDartString(key.description || '')}',
args: [${placeholders.join(', ')}],
);
}`;
        }

        // 3. Handle simple getters
        return `  /// \`${escapedDescription}\`
String get ${key.key} {
return Intl.message(
'${this.escapeDartString(defaultTranslation)}',
name: '${moduleName}_${key.key}',
desc: '${this.escapeDartString(key.description || '')}',
args: [],
);
}`;
    }

    /**
     * Helper to extract ICU plural parts like =0{...} or other{...}
     */
    private extractPluralPart(icuString: string, part: string): string {
        // Find the start of the part, e.g., "other{"
        const searchString = `${part}{`;
        const startIndex = icuString.indexOf(searchString);
        if (startIndex === -1) return '';

        const contentStart = startIndex + searchString.length;
        let bracketCount = 1;
        let contentEnd = contentStart;

        // Manually find the matching closing brace to handle nested {count}
        for (let i = contentStart;i < icuString.length;i++) {
            if (icuString[i] === '{') bracketCount++;
            else if (icuString[i] === '}') bracketCount--;
            if (bracketCount === 0) {
                contentEnd = i;
                break;
            }
        }

        const rawContent = icuString.substring(contentStart, contentEnd);

        // Convert ICU variable syntax {count} to Dart string interpolation $count
        // But ONLY if it's not a plural keyword
        return this.escapeDartString(rawContent).replace(/\{(\w+)\}/g, '$$$1');
    }

    private getPlaceholderType(key: TranslationKey, placeholderName: string): string {
        if (key.placeholders && key.placeholders[placeholderName]) {
            const type = key.placeholders[placeholderName].type;
            switch (type) {
                case 'int':
                case 'num':
                case 'double':
                    return type;
                case 'DateTime':
                    return 'DateTime';
                default:
                    return 'Object';
            }
        }
        return 'Object';
    }

    private async generateDelegate(modules: ParsedModule[]): Promise<void> {
        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
import 'package:flutter/material.dart';
import '${this.toSnakeCase(this.config.className)}.dart';

class AppLocalizationDelegate extends LocalizationsDelegate<${this.config.className}> {
const AppLocalizationDelegate();

@override
bool isSupported(Locale locale) {
return ${this.config.className}.supportedLocales.any(
(supportedLocale) => supportedLocale.languageCode == locale.languageCode,
);
}

@override
Future<${this.config.className}> load(Locale locale) => ${this.config.className}.load(locale);

@override
bool shouldReload(AppLocalizationDelegate old) => false;
}
`;

        const filePath = path.join(this.config.outputPath, 'app_localization_delegate.dart');
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private async generateMessagesFiles(modules: ParsedModule[]): Promise<void> {
        const messagesDir = path.join(this.config.outputPath, 'intl');
        fs.mkdirSync(messagesDir, { recursive: true });

        for (const locale of this.config.supportedLocales) {
            const messages: Record<string, string> = {};
            for (const module of modules) {
                for (const key of module.keys) {
                    const translation =
                        key.translations[locale] ||
                        key.translations[this.config.defaultLocale] ||
                        '';
                    messages[`${module.name}_${key.key}`] = translation;
                }
            }

            const content = this.generateMessagesFileContent(locale, messages);
            const filePath = path.join(messagesDir, `messages_${locale}.dart`);
            fs.writeFileSync(filePath, content, 'utf-8');
        }

        // Generate messages_all.dart
        await this.generateMessagesAll(modules);
    }

    // modular_l10n_extension/src/dart_generator.ts
    private generateMessagesFileContent(locale: string, messages: Record<string, string>): string {
        const messageEntries = Object.entries(messages)
            .map(([key, value]) => {
                const placeholders = ArbParser.extractPlaceholders(value);
                const isIcu = ArbParser.hasIcuSyntax(value);

                // 1. Handle ICU Plural/Select syntax
                if (isIcu) {
                    // Extract the variable name from the ICU string (e.g., "count" from "{count, plural, ...}")
                    const icuVarMatch = value.match(/\{(\w+),/);
                    const icuVar = icuVarMatch ? icuVarMatch[1] : 'count';

                    // Process the value: escape it, then convert ICU {var} to Dart ${var}
                    // We use a specific regex to find the variables to avoid breaking the ICU structure
                    const processedValue = this.escapeDartString(value).replace(/\{(\w+)\}/g, '$$$1');

                    return `    '${key}': (${icuVar}) => '${processedValue}',`;
                }

                // 2. Handle standard methods with parameters
                if (placeholders.length > 0) {
                    const argList = placeholders.join(', ');
                    const processedValue = this.escapeDartString(value).replace(/\{(\w+)\}/g, '$$$1');

                    return `    '${key}': (${argList}) => '${processedValue}',`;
                }

                // 3. Handle simple static messages
                return `    '${key}': MessageLookupByLibrary.simpleMessage('${this.escapeDartString(value)}'),`;
            })
            .join('\n');

        return `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = MessageLookup();

typedef MessageIfAbsent = String Function(String messageStr, List<Object> args);

class MessageLookup extends MessageLookupByLibrary {
@override
String get localeName => '${locale}';

@override
final messages = <String, Function>{
${messageEntries}
};
}
`;
    }

    private async generateMessagesAll(modules: ParsedModule[]): Promise<void> {
        const localeImports = this.config.supportedLocales
            .map((l) => `import 'messages_${l}.dart' as messages_${l};`)
            .join('\n');

        const localeMap = this.config.supportedLocales
            .map((l) => `    '${l}': messages_${l}.messages,`)
            .join('\n');

        const content = `//GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
// ADD THIS LINE BELOW:
import 'package:intl/src/intl_helpers.dart';

${localeImports}

typedef LibraryLoader = Future<dynamic> Function();

Map<String, LibraryLoader> _deferredLibraries = {
${this.config.supportedLocales.map((l) => `  '${l}': () => Future.value(null),`).join('\n')}
};

MessageLookupByLibrary? _findExact(String localeName) {
switch (localeName) {
${this.config.supportedLocales.map((l) => `    case '${l}':
return messages_${l}.messages;`).join('\n')}
default:
return null;
}
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
final actualLocale = Intl.verifiedLocale(
locale,
(locale) => _deferredLibraries[locale] != null,
onFailure: (_) => null,
);
if (actualLocale == null) return null;
return _findExact(actualLocale);
}

Future<bool> initializeMessages(String localeName) async {
final availableLocale = Intl.verifiedLocale(
localeName,
(locale) => _deferredLibraries[locale] != null,
onFailure: (_) => null,
);
if (availableLocale == null) {
return false;
}
final lib = _deferredLibraries[availableLocale];
await lib?.call();
initializeInternalMessageLookup(() => CompositeMessageLookup());
messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
return true;
}
`;

        const filePath = path.join(this.config.outputPath, 'intl', 'messages_all.dart');
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private async generateCombinedArbFiles(modules: ParsedModule[]): Promise<void> {
        const arbDir = path.join(this.config.outputPath, 'arb');
        fs.mkdirSync(arbDir, { recursive: true });

        for (const locale of this.config.supportedLocales) {
            const combinedArb: Record<string, unknown> = {
                '@@locale': locale,
                '@@last_modified': new Date().toISOString(),
            };

            for (const module of modules) {
                for (const key of module.keys) {
                    const fullKey = `${module.name}_${key.key}`;
                    combinedArb[fullKey] =
                        key.translations[locale] ||
                        key.translations[this.config.defaultLocale] ||
                        '';

                    if (key.description || key.placeholders) {
                        combinedArb[`@${fullKey}`] = {
                            description: key.description,
                            placeholders: key.placeholders,
                        };
                    }
                }
            }

            const filePath = path.join(arbDir, `intl_${locale}.arb`);
            fs.writeFileSync(filePath, JSON.stringify(combinedArb, null, 2), 'utf-8');
        }
    }

    private async generateBarrelFile(modules: ParsedModule[]): Promise<void> {
        const exports = [
            `export '${this.toSnakeCase(this.config.className)}.dart';`,
            `export 'app_localization_delegate.dart';`,
            ...modules.map((m) => `export '${this.toSnakeCase(m.name)}_l10n.dart';`),
        ];

        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
${exports.join('\n')}
`;

        const filePath = path.join(this.config.outputPath, 'l10n.dart');
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private toPascalCase(str: string): string {
        return str
            .split(/[_-]/)
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('');
    }

    private toCamelCase(str: string): string {
        const pascal = this.toPascalCase(str);
        return pascal.charAt(0).toLowerCase() + pascal.slice(1);
    }

    private toSnakeCase(str: string): string {
        return str
            .replace(/([a-z])([A-Z])/g, '$1_$2')
            .replace(/[-\s]/g, '_')
            .toLowerCase();
    }

    private escapeDartString(str: string): string {
        return str
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
            .replace(/\$/g, '\\$');
    }
}