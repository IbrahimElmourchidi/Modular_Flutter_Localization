import * as fs from 'fs';
import * as path from 'path';
import { ParsedModule, TranslationKey, PlaceholderInfo } from './arb_parser';
import { ArbParser } from './arb_parser';

export interface GeneratorConfig {
    outputPath: string;
    className: string;
    defaultLocale: string;
    supportedLocales: string[];
    generateCombinedArb: boolean;
    useDeferredLoading: boolean;
}

export class DartGenerator {
    constructor(private config: GeneratorConfig) {}

    async generate(modules: ParsedModule[]): Promise<void> {
        // Ensure output directory exists
        fs.mkdirSync(this.config.outputPath, { recursive: true });

        // Generate main ML class
        await this.generateMainClass(modules);

        // Generate module classes
        for (const module of modules) {
            await this.generateModuleClass(module);
        }

        // Generate delegate
        await this.generateDelegate(modules);

        // Generate messages files for each locale
        await this.generateMessagesFiles(modules);

        // Generate combined ARB files if enabled
        if (this.config.generateCombinedArb) {
            await this.generateCombinedArbFiles(modules);
        }

        // Generate barrel file
        await this.generateBarrelFile(modules);
    }

    private async generateMainClass(modules: ParsedModule[]): Promise<void> {
        const moduleImports = modules
            .map((m) => `import '${this.toSnakeCase(m.name)}_l10n.dart';`)
            .join('\n');

        const moduleGetters = modules
            .map((m) => {
                const className = this.toPascalCase(m.name) + 'L10n';
                const fieldName = this.toCamelCase(m.name);
                return `  ${className} get ${fieldName} => _${fieldName}!;
  static ${className}? _${fieldName};`;
            })
            .join('\n');

        const moduleLoaders = modules
            .map((m) => {
                const className = this.toPascalCase(m.name) + 'L10n';
                const fieldName = this.toCamelCase(m.name);
                return `    _${fieldName} = ${className}.load(localeName);`;
            })
            .join('\n');

        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
// ignore_for_file: non_constant_identifier_names, unnecessary_string_interpolations, unnecessary_string_escapes
import 'app_localization_delegate.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/modular_messages_all.dart';
${moduleImports}

/// Main Modular Localization class providing access to all module translations.
///
/// In widgets (registers dependency — auto-rebuilds on locale change):
/// \`\`\`dart
/// Text(${this.config.className}.of(context).auth.email)
/// Text(${this.config.className}.of(context).home.welcomeMessage)
/// \`\`\`
///
/// In non-widget code (services, cubits, etc.):
/// \`\`\`dart
/// final title = ${this.config.className}.current.auth.email;
/// \`\`\`
class ${this.config.className} {
  ${this.config.className}._();

  static ${this.config.className}? _current;

  static ${this.config.className} get current {
    assert(
      _current != null,
      'No instance of ${this.config.className} was loaded. '
      'Try to initialize the ${this.config.className} delegate before accessing ${this.config.className}.current.',
    );
    return _current!;
  }

${moduleGetters}

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<${this.config.className}> load(Locale locale) async {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    Intl.defaultLocale = localeName;

    // Register message lookup tables for the locale
    await initializeModularMessages(localeName);

    final instance = ${this.config.className}._();
    ${this.config.className}._current = instance;

    // Load all module translations
${moduleLoaders}

    return instance;
  }

  static ${this.config.className} of(BuildContext context) {
    final instance = ${this.config.className}.maybeOf(context);
    assert(
      instance != null,
      'No instance of ${this.config.className} present in the widget tree. '
      'Did you add ${this.config.className}.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static ${this.config.className}? maybeOf(BuildContext context) {
    return Localizations.of<${this.config.className}>(context, ${this.config.className});
  }

  /// List of all supported locales
  static const List<Locale> supportedLocales = [
${this.config.supportedLocales.map((l) => this.generateLocaleConstructor(l)).join(',\n')}
  ];
}
`;

        const filePath = path.join(
            this.config.outputPath,
            `${this.toSnakeCase(this.config.className)}.dart`
        );
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    /**
     * Generate proper Locale constructor for complex locales.
     * Handles: en, en_US, zh_Hans, zh_Hans_CN
     */
    private generateLocaleConstructor(locale: string): string {
        const parts = locale.split('_');

        if (parts.length === 1) {
            return `    Locale('${parts[0]}')`;
        } else if (parts.length === 2) {
            const [lang, second] = parts;
            if (/^[A-Z][a-z]{3}$/.test(second)) {
                return `    Locale.fromSubtags(languageCode: '${lang}', scriptCode: '${second}')`;
            } else {
                return `    Locale('${lang}', '${second}')`;
            }
        } else if (parts.length === 3) {
            const [lang, script, region] = parts;
            return `    Locale.fromSubtags(languageCode: '${lang}', scriptCode: '${script}', countryCode: '${region}')`;
        }

        return `    Locale('${locale}')`;
    }

    private async generateModuleClass(module: ParsedModule): Promise<void> {
        const className = this.toPascalCase(module.name) + 'L10n';

        const methods = module.keys
            .map((key) => this.generateMethod(key, module.name))
            .join('\n\n');

        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
// Module: ${module.name}
// ignore_for_file: non_constant_identifier_names, unnecessary_string_interpolations, unnecessary_string_escapes
import 'package:intl/intl.dart';

/// Localization class for the ${module.name} module.
class ${className} {
  ${className}._();

  static ${className}? _instance;

  static ${className} load(String localeName) {
    _instance = ${className}._();
    return _instance!;
  }

  static ${className} get instance {
    assert(_instance != null, '${className} not loaded');
    return _instance!;
  }

${methods}
}
`;

        const filePath = path.join(
            this.config.outputPath,
            `${this.toSnakeCase(module.name)}_l10n.dart`
        );
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private generateMethod(key: TranslationKey, moduleName: string): string {
        const defaultTranslation = key.translations[this.config.defaultLocale] || '';

        // Get ordered placeholders (respects metadata order if specified)
        const placeholders = ArbParser.getOrderedPlaceholders(defaultTranslation, key.placeholders);

        const hasIcuSyntax = ArbParser.hasIcuSyntax(defaultTranslation);
        const icuType = ArbParser.getIcuType(defaultTranslation);

        const description = key.description || defaultTranslation;
        const escapedDescription = this.escapeForDartDoc(description);

        // Validate ICU syntax if present
        if (hasIcuSyntax) {
            const validation = ArbParser.validateIcuSyntax(defaultTranslation);
            if (!validation.valid) {
                console.warn(`Warning: Invalid ICU syntax in ${moduleName}.${key.key}: ${validation.error}`);
            }
        }

        // 0. Handle compound messages (multiple ICU expressions in one string)
        if (ArbParser.isCompoundMessage(defaultTranslation)) {
            return this.generateCompoundMethod(key, moduleName, defaultTranslation, escapedDescription);
        }

        // 1. Handle ICU Plural Syntax
        if (icuType === 'plural' || icuType === 'selectordinal') {
            return this.generatePluralMethod(key, moduleName, defaultTranslation, escapedDescription, icuType);
        }

        // 2. Handle ICU Select Syntax
        if (icuType === 'select') {
            return this.generateSelectMethod(key, moduleName, defaultTranslation, escapedDescription);
        }

        // 3. Handle standard methods with parameters
        if (placeholders.length > 0) {
            return this.generateParameterizedMethod(key, moduleName, defaultTranslation, escapedDescription, placeholders);
        }

        // 4. Handle simple getters
        return `  /// ${escapedDescription}
  String get ${key.key} {
    return Intl.message(
      '${this.escapeDartString(defaultTranslation)}',
      name: '${moduleName}_${key.key}',
      desc: '${this.escapeDartString(key.description || '')}',
      args: [],
    );
  }`;
    }

    /**
     * Generate a method for plural/selectordinal ICU messages.
     */
    private generatePluralMethod(
        key: TranslationKey,
        moduleName: string,
        defaultTranslation: string,
        escapedDescription: string,
        icuType: 'plural' | 'selectordinal'
    ): string {
        const icuVarMatch = defaultTranslation.match(/\{(\w+)\s*,\s*(plural|selectordinal)\s*,/);
        const icuVar = icuVarMatch ? icuVarMatch[1] : 'count';

        const cases = this.extractPluralCases(defaultTranslation);

        return `  /// ${escapedDescription}
  String ${key.key}(int ${icuVar}) {
    return Intl.${icuType === 'selectordinal' ? 'plural' : 'plural'}(
      ${icuVar},
${this.generatePluralCaseLines(cases)}
      name: '${moduleName}_${key.key}',
      desc: '${this.escapeDartString(key.description || '')}',
      args: [${icuVar}],
    );
  }`;
    }

    /**
     * Generate a method for select ICU messages.
     */
    private generateSelectMethod(
        key: TranslationKey,
        moduleName: string,
        defaultTranslation: string,
        escapedDescription: string
    ): string {
        const icuVarMatch = defaultTranslation.match(/\{(\w+)\s*,\s*select\s*,/);
        const icuVar = icuVarMatch ? icuVarMatch[1] : 'choice';

        return `  /// ${escapedDescription}
  String ${key.key}(String ${icuVar}) {
    return Intl.select(
      ${icuVar},
      ${this.extractSelectCases(defaultTranslation, icuVar)},
      name: '${moduleName}_${key.key}',
      desc: '${this.escapeDartString(key.description || '')}',
      args: [${icuVar}],
    );
  }`;
    }

    /**
     * Generate a method for compound messages (multiple ICU expressions in one string).
     * e.g., "{gender, select, male{He} other{They}} bought {count, plural, one{1 item} other{{count} items}}"
     *
     * Strategy: collect all ICU variables with their types, generate a method that
     * takes all of them as params, and build a Dart expression with embedded
     * Intl.plural/Intl.select calls.
     */
    private generateCompoundMethod(
        key: TranslationKey,
        moduleName: string,
        defaultTranslation: string,
        escapedDescription: string
    ): string {
        const segments = ArbParser.getIcuSegments(defaultTranslation);
        const allPlaceholders = ArbParser.extractPlaceholders(defaultTranslation);

        // Build parameter list: ICU variables get typed (int for plural, String for select),
        // remaining simple placeholders get Object
        const paramParts: string[] = [];
        const addedParams = new Set<string>();

        for (const seg of segments) {
            if (addedParams.has(seg.variable)) continue;
            addedParams.add(seg.variable);
            const dartType = (seg.type === 'plural' || seg.type === 'selectordinal') ? 'int' : 'String';
            paramParts.push(`${dartType} ${seg.variable}`);
        }

        for (const p of allPlaceholders) {
            if (addedParams.has(p)) continue;
            addedParams.add(p);
            paramParts.push(`${this.getPlaceholderDartType(key, p)} ${p}`);
        }

        const params = paramParts.join(', ');
        const args = Array.from(addedParams).join(', ');

        const dartExpression = this.buildCompoundDartExpression(defaultTranslation, segments);

        return `  /// ${escapedDescription}
  String ${key.key}(${params}) {
    return Intl.message(
      ${dartExpression},
      name: '${moduleName}_${key.key}',
      desc: '${this.escapeDartString(key.description || '')}',
      args: [${args}],
    );
  }`;
    }

    /**
     * Convert a compound ICU string into a Dart expression with embedded Intl.plural/select calls.
     * Input:  "{gender, select, male{He} other{They}} bought {count, plural, one{1 item} other{{count} items}}"
     * Output: "${Intl.select(gender, {'male': 'He', 'other': 'They'})} bought ${Intl.plural(count, one: '1 item', other: '$count items')}"
     */
    private buildCompoundDartExpression(
        text: string,
        segments: ReturnType<typeof ArbParser.getIcuSegments>
    ): string {
        // Process from right to left so indices stay valid
        const sorted = [...segments].sort((a, b) => b.start - a.start);
        let result = text;

        for (const seg of sorted) {
            let replacement: string;

            if (seg.type === 'plural' || seg.type === 'selectordinal') {
                const cases = this.extractPluralCases(seg.raw);
                const caseArgs = this.buildInlinePluralArgs(cases);
                replacement = `\${Intl.plural(${seg.variable}, ${caseArgs})}`;
            } else {
                const casesStr = this.extractSelectCases(seg.raw, seg.variable);
                const inlineCases = casesStr.replace(/\n\s*/g, ' ').trim();
                replacement = `\${Intl.select(${seg.variable}, ${inlineCases})}`;
            }

            result = result.substring(0, seg.start) + replacement + result.substring(seg.end);
        }

        // Convert any remaining simple {var} placeholders to $var
        result = result.replace(/\{(\w+)\}/g, (_, varName) => {
            if (['plural', 'select', 'selectordinal'].includes(varName)) return `{${varName}}`;
            return `\$${varName}`;
        });

        return `'${this.escapeDartString(result)}'`;
    }

    /**
     * Build inline plural case arguments for compound expressions.
     * Returns: "zero: 'none', one: '1 item', other: '$count items'"
     */
    private buildInlinePluralArgs(cases: Map<string, string>): string {
        const explicitToDartParam: Record<string, string> = { '=0': 'zero', '=1': 'one', '=2': 'two' };
        const namedOrder = ['zero', 'one', 'two', 'few', 'many', 'other'];
        const resolved = new Map<string, string>();

        for (const [caseName, content] of cases.entries()) {
            if (caseName.startsWith('=')) {
                const param = explicitToDartParam[caseName];
                if (param && content.trim() && !resolved.has(param)) {
                    resolved.set(param, content);
                }
            }
        }
        for (const name of namedOrder) {
            const content = cases.get(name);
            if (content !== undefined && content.trim()) {
                resolved.set(name, content);
            }
        }

        const parts: string[] = [];
        for (const name of namedOrder) {
            const content = resolved.get(name);
            if (content !== undefined) {
                parts.push(`${name}: '${this.escapeDartString(content)}'`);
            }
        }
        return parts.join(', ');
    }

    /**
     * Generate a method with parameters.
     * Supports number/DateTime formatting from placeholder metadata.
     */
    private generateParameterizedMethod(
        key: TranslationKey,
        moduleName: string,
        defaultTranslation: string,
        escapedDescription: string,
        placeholders: string[]
    ): string {
        const params = placeholders
            .map((p) => `${this.getPlaceholderDartType(key, p)} ${p}`)
            .join(', ');

        // Check if any placeholders need formatting
        const formattingLines = this.generateFormattingLines(key, placeholders);

        if (formattingLines.length > 0) {
            // Build the formatted variables and message
            const formattedVars = formattingLines.map((f) => f.varDeclaration).join('\n    ');
            const args = placeholders.map((p) => {
                const fmt = formattingLines.find((f) => f.placeholder === p);
                return fmt ? fmt.formattedVar : p;
            });

            // Replace placeholders in the message with formatted versions
            let messageStr = defaultTranslation;
            for (const fmt of formattingLines) {
                messageStr = messageStr.replace(
                    new RegExp(`\\{${fmt.placeholder}\\}`, 'g'),
                    `\${${fmt.formattedVar}}`
                );
            }
            // Replace remaining simple placeholders
            for (const p of placeholders) {
                if (!formattingLines.find((f) => f.placeholder === p)) {
                    messageStr = messageStr.replace(
                        new RegExp(`\\{${p}\\}`, 'g'),
                        `\$${p}`
                    );
                }
            }

            return `  /// ${escapedDescription}
  String ${key.key}(${params}) {
    ${formattedVars}
    return Intl.message(
      '${this.escapeDartString(defaultTranslation)}',
      name: '${moduleName}_${key.key}',
      desc: '${this.escapeDartString(key.description || '')}',
      args: [${args.join(', ')}],
    );
  }`;
        }

        return `  /// ${escapedDescription}
  String ${key.key}(${params}) {
    return Intl.message(
      '${this.escapeDartString(defaultTranslation)}',
      name: '${moduleName}_${key.key}',
      desc: '${this.escapeDartString(key.description || '')}',
      args: [${placeholders.join(', ')}],
    );
  }`;
    }

    /**
     * Generate formatting lines for placeholders with format metadata.
     * Supports NumberFormat and DateFormat.
     */
    private generateFormattingLines(
        key: TranslationKey,
        placeholders: string[]
    ): { placeholder: string; varDeclaration: string; formattedVar: string }[] {
        const lines: { placeholder: string; varDeclaration: string; formattedVar: string }[] = [];

        if (!key.placeholders) return lines;

        for (const pName of placeholders) {
            const meta = key.placeholders[pName];
            if (!meta || !meta.format) continue;

            const formattedVar = `${pName}String`;

            if (meta.type === 'DateTime') {
                if (meta.isCustomDateFormat === 'true') {
                    // Custom date format
                    lines.push({
                        placeholder: pName,
                        varDeclaration: `final ${formattedVar} = DateFormat('${this.escapeDartString(meta.format)}').format(${pName});`,
                        formattedVar,
                    });
                } else {
                    // Named date format (e.g., yMd, Hm)
                    lines.push({
                        placeholder: pName,
                        varDeclaration: `final ${formattedVar} = DateFormat.${meta.format}().format(${pName});`,
                        formattedVar,
                    });
                }
            } else if (meta.type === 'int' || meta.type === 'double' || meta.type === 'num') {
                // Number formatting
                const optParams = meta.optionalParameters;
                if (optParams) {
                    const paramEntries = Object.entries(optParams)
                        .map(([k, v]) => {
                            if (typeof v === 'number') return `${k}: ${v}`;
                            return `${k}: '${this.escapeDartString(String(v))}'`;
                        })
                        .join(', ');
                    lines.push({
                        placeholder: pName,
                        varDeclaration: `final ${formattedVar} = NumberFormat.${meta.format}(${paramEntries ? paramEntries : ''}).format(${pName});`,
                        formattedVar,
                    });
                } else {
                    lines.push({
                        placeholder: pName,
                        varDeclaration: `final ${formattedVar} = NumberFormat.${meta.format}().format(${pName});`,
                        formattedVar,
                    });
                }
            }
        }

        return lines;
    }

    /**
     * Extract plural cases from an ICU message.
     * Properly handles nested braces.
     */
    private extractPluralCases(icuString: string): Map<string, string> {
        const cases = new Map<string, string>();
        const caseNames = ['=0', '=1', '=2', 'zero', 'one', 'two', 'few', 'many', 'other'];

        for (const caseName of caseNames) {
            const content = this.extractCaseContent(icuString, caseName);
            if (content !== null) {
                cases.set(caseName, content);
            }
        }

        return cases;
    }

    /**
     * Extract the content of a specific case from an ICU message.
     * Properly handles nested braces.
     */
    private extractCaseContent(icuString: string, caseName: string): string | null {
        // Match the case with possible whitespace before the opening brace
        const searchPatterns = [
            `${caseName}{`,
            `${caseName} {`,
        ];

        let startIndex = -1;
        let searchLen = 0;

        for (const pattern of searchPatterns) {
            const idx = icuString.indexOf(pattern);
            if (idx !== -1 && (startIndex === -1 || idx < startIndex)) {
                startIndex = idx;
                searchLen = pattern.length;
            }
        }

        if (startIndex === -1) {
            return null;
        }

        const contentStart = startIndex + searchLen;
        let bracketCount = 1;
        let contentEnd = contentStart;

        for (let i = contentStart; i < icuString.length; i++) {
            if (icuString[i] === '{') {
                bracketCount++;
            } else if (icuString[i] === '}') {
                bracketCount--;
                if (bracketCount === 0) {
                    contentEnd = i;
                    break;
                }
            }
        }

        const rawContent = icuString.substring(contentStart, contentEnd);

        // Convert nested placeholders from ICU format {var} to Dart format $var
        return this.convertIcuPlaceholdersToDart(rawContent);
    }

    /**
     * Convert ICU placeholders {var} to Dart string interpolation $var.
     * Only converts simple variable references, not ICU keywords.
     */
    private convertIcuPlaceholdersToDart(text: string): string {
        return text.replace(/\{(\w+)\}/g, (match, varName) => {
            if (['plural', 'select', 'selectordinal'].includes(varName)) {
                return match;
            }
            return `\$${varName}`;
        });
    }

    /**
     * Generate Dart code lines for plural cases.
     * FIXED: Maps =0→zero, =1→one, =2→two (valid Dart Intl.plural named params)
     */
    private generatePluralCaseLines(cases: Map<string, string>): string {
        const lines: string[] = [];

        // Mapping from explicit number cases to Dart Intl.plural named parameters
        const explicitToDartParam: Record<string, string> = {
            '=0': 'zero',
            '=1': 'one',
            '=2': 'two',
        };

        // Named plural cases in Dart Intl.plural order
        const namedCases = ['zero', 'one', 'two', 'few', 'many', 'other'];

        // Collect which named params are set (from explicit or named)
        const resolvedCases = new Map<string, string>();

        // First, add explicit cases mapped to named params
        for (const [caseName, content] of cases.entries()) {
            if (caseName.startsWith('=')) {
                const dartParam = explicitToDartParam[caseName];
                if (dartParam && content.trim()) {
                    // Only set if not already set by a named case
                    if (!resolvedCases.has(dartParam)) {
                        resolvedCases.set(dartParam, content);
                    }
                }
            }
        }

        // Then, add named cases (these take priority if both =0 and zero exist)
        for (const caseName of namedCases) {
            const content = cases.get(caseName);
            if (content !== undefined && content.trim()) {
                resolvedCases.set(caseName, content);
            }
        }

        // Generate output lines in the correct order
        for (const caseName of namedCases) {
            const content = resolvedCases.get(caseName);
            if (content !== undefined) {
                lines.push(`      ${caseName}: '${this.escapeDartString(content)}',`);
            }
        }

        return lines.join('\n');
    }

    /**
     * Extract select cases and generate Dart Map.
     * FIXED: Properly handles nested braces in case content.
     */
    private extractSelectCases(icuString: string, icuVar: string): string {
        const cases: string[] = [];

        // Find the start of the select body (after "{var, select,")
        const selectStart = icuString.match(/\{\w+\s*,\s*select\s*,/);
        if (!selectStart) {
            return '{}';
        }

        const bodyStart = (selectStart.index ?? 0) + selectStart[0].length;
        let pos = bodyStart;

        // Parse each case: caseName{content}
        while (pos < icuString.length) {
            // Skip whitespace
            while (pos < icuString.length && /\s/.test(icuString[pos])) {
                pos++;
            }

            // Check if we hit the closing brace of the select
            if (icuString[pos] === '}') {
                break;
            }

            // Read case name
            const caseNameMatch = icuString.substring(pos).match(/^(\w+)\s*\{/);
            if (!caseNameMatch) {
                break;
            }

            const caseName = caseNameMatch[1];
            pos += caseNameMatch[0].length;

            // Read content with balanced braces
            let braceDepth = 1;
            let contentStart = pos;

            while (pos < icuString.length && braceDepth > 0) {
                if (icuString[pos] === '{') braceDepth++;
                else if (icuString[pos] === '}') braceDepth--;
                if (braceDepth > 0) pos++;
            }

            const content = icuString.substring(contentStart, pos);
            pos++; // skip closing brace

            // Convert ICU placeholders to Dart interpolation
            const processedContent = this.convertIcuPlaceholdersToDart(content);
            cases.push(`'${caseName}': '${this.escapeDartString(processedContent)}'`);
        }

        return `{\n        ${cases.join(',\n        ')},\n      }`;
    }

    /**
     * Get the Dart type for a placeholder, including proper DateTime support.
     */
    private getPlaceholderDartType(key: TranslationKey, placeholderName: string): string {
        if (key.placeholders && key.placeholders[placeholderName]) {
            const type = key.placeholders[placeholderName].type;
            switch (type) {
                case 'int':
                    return 'int';
                case 'num':
                    return 'num';
                case 'double':
                    return 'double';
                case 'DateTime':
                    return 'DateTime';
                case 'String':
                    return 'String';
                default:
                    return 'Object';
            }
        }
        return 'Object';
    }

    private async generateDelegate(modules: ParsedModule[]): Promise<void> {
        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
// ignore_for_file: non_constant_identifier_names
import 'package:flutter/material.dart';
import '${this.toSnakeCase(this.config.className)}.dart';

class AppLocalizationDelegate extends LocalizationsDelegate<${this.config.className}> {
  const AppLocalizationDelegate();

  @override
  bool isSupported(Locale locale) {
    return ${this.config.className}.supportedLocales.any(
      (supportedLocale) => supportedLocale.languageCode == locale.languageCode,
    );
  }

  @override
  Future<${this.config.className}> load(Locale locale) => ${this.config.className}.load(locale);

  @override
  bool shouldReload(AppLocalizationDelegate old) => false;
}
`;

        const filePath = path.join(this.config.outputPath, 'app_localization_delegate.dart');
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private async generateMessagesFiles(modules: ParsedModule[]): Promise<void> {
        const messagesDir = path.join(this.config.outputPath, 'intl');
        fs.mkdirSync(messagesDir, { recursive: true });

        for (const locale of this.config.supportedLocales) {
            const messages: { key: string; value: string; translationKey: TranslationKey }[] = [];
            for (const module of modules) {
                for (const key of module.keys) {
                    const translation =
                        key.translations[locale] ||
                        key.translations[this.config.defaultLocale] ||
                        '';
                    messages.push({
                        key: `${module.name}_${key.key}`,
                        value: translation,
                        translationKey: key,
                    });
                }
            }

            const content = this.generateMessagesFileContent(locale, messages);
            // FIXED: Namespaced file to avoid Flutter Intl conflict
            const filePath = path.join(messagesDir, `modular_messages_${locale}.dart`);
            fs.writeFileSync(filePath, content, 'utf-8');
        }

        // Generate modular_messages_all.dart
        await this.generateMessagesAll(modules);
    }

    /**
     * Generate messages file with proper ICU handling.
     * FIXED: Correct Dart string interpolation for parameterized messages.
     */
    private generateMessagesFileContent(
        locale: string,
        messages: { key: string; value: string; translationKey: TranslationKey }[]
    ): string {
        const messageEntries = messages
            .map(({ key, value, translationKey }) => {
                const placeholders = ArbParser.extractPlaceholders(value);
                const icuType = ArbParser.getIcuType(value);

                // 0. Handle compound messages (multiple ICU expressions)
                if (ArbParser.isCompoundMessage(value)) {
                    return this.generateMessageCompoundEntry(key, value, translationKey);
                }

                // 1. Handle ICU Plural/Selectordinal syntax
                if (icuType === 'plural' || icuType === 'selectordinal') {
                    const icuVarMatch = value.match(/\{(\w+)\s*,\s*(plural|selectordinal)\s*,/);
                    const icuVar = icuVarMatch ? icuVarMatch[1] : 'count';
                    const cases = this.extractPluralCases(value);
                    return this.generateMessagePluralEntry(key, icuVar, cases);
                }

                // 2. Handle ICU Select syntax
                if (icuType === 'select') {
                    const icuVarMatch = value.match(/\{(\w+)\s*,\s*select\s*,/);
                    const icuVar = icuVarMatch ? icuVarMatch[1] : 'choice';
                    return this.generateMessageSelectEntry(key, icuVar, value);
                }

                // 3. Handle standard methods with parameters
                if (placeholders.length > 0) {
                    const argList = placeholders.join(', ');
                    // FIXED: Use proper Dart string interpolation with escaped message
                    const escapedValue = this.escapeDartString(value);
                    // Replace {varName} with ${varName} for Dart string interpolation
                    const interpolated = escapedValue.replace(
                        /\{(\w+)\}/g,
                        (_, varName) => `\${${varName}}`
                    );
                    return `    '${key}': (${argList}) => '${interpolated}',`;
                }

                // 4. Handle simple static messages
                return `    '${key}': MessageLookupByLibrary.simpleMessage('${this.escapeDartString(value)}'),`;
            })
            .join('\n');

        return `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
// ignore_for_file: non_constant_identifier_names, unnecessary_string_interpolations, unnecessary_string_escapes
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = ModularMessageLookup();

typedef MessageIfAbsent = String Function(String messageStr, List<Object> args);

class ModularMessageLookup extends MessageLookupByLibrary {
  @override
  String get localeName => '${locale}';

  @override
  final messages = <String, Function>{
${messageEntries}
  };
}
`;
    }

    /**
     * Generate a compound message entry for the messages file.
     * Builds a function with embedded Intl.plural/Intl.select calls.
     */
    private generateMessageCompoundEntry(
        key: string,
        value: string,
        translationKey: TranslationKey
    ): string {
        const segments = ArbParser.getIcuSegments(value);
        const allPlaceholders = ArbParser.extractPlaceholders(value);

        // Collect all parameter names
        const paramNames: string[] = [];
        const addedParams = new Set<string>();

        for (const seg of segments) {
            if (!addedParams.has(seg.variable)) {
                addedParams.add(seg.variable);
                paramNames.push(seg.variable);
            }
        }
        for (const p of allPlaceholders) {
            if (!addedParams.has(p)) {
                addedParams.add(p);
                paramNames.push(p);
            }
        }

        const argList = paramNames.join(', ');

        // Build expression by replacing each ICU segment with Dart equivalent
        const sorted = [...segments].sort((a, b) => b.start - a.start);
        let result = value;

        for (const seg of sorted) {
            let replacement: string;

            if (seg.type === 'plural' || seg.type === 'selectordinal') {
                const cases = this.extractPluralCases(seg.raw);
                const caseArgs = this.buildInlinePluralArgs(cases);
                replacement = `\${Intl.plural(${seg.variable}, ${caseArgs})}`;
            } else {
                const casesStr = this.extractSelectCases(seg.raw, seg.variable);
                const inlineCases = casesStr.replace(/\n\s*/g, ' ').trim();
                replacement = `\${Intl.select(${seg.variable}, ${inlineCases})}`;
            }

            result = result.substring(0, seg.start) + replacement + result.substring(seg.end);
        }

        // Convert remaining simple {var} to ${var}
        result = result.replace(/\{(\w+)\}/g, (_, varName) => {
            if (['plural', 'select', 'selectordinal'].includes(varName)) return `{${varName}}`;
            return `\${${varName}}`;
        });

        return `    '${key}': (${argList}) => '${this.escapeDartString(result)}',`;
    }

    /**
     * Generate a plural message entry for the messages file using Intl.plural.
     */
    private generateMessagePluralEntry(
        key: string,
        icuVar: string,
        cases: Map<string, string>
    ): string {
        const caseParts: string[] = [];
        const explicitToDartParam: Record<string, string> = { '=0': 'zero', '=1': 'one', '=2': 'two' };
        const namedOrder = ['zero', 'one', 'two', 'few', 'many', 'other'];
        const resolved = new Map<string, string>();

        for (const [caseName, content] of cases.entries()) {
            if (caseName.startsWith('=')) {
                const param = explicitToDartParam[caseName];
                if (param && content.trim() && !resolved.has(param)) {
                    resolved.set(param, content);
                }
            }
        }
        for (const name of namedOrder) {
            const content = cases.get(name);
            if (content !== undefined && content.trim()) {
                resolved.set(name, content);
            }
        }

        for (const name of namedOrder) {
            const content = resolved.get(name);
            if (content !== undefined) {
                caseParts.push(`${name}: '${this.escapeDartString(content)}'`);
            }
        }

        return `    '${key}': (${icuVar}) => Intl.plural(${icuVar}, ${caseParts.join(', ')}, name: '${key}', args: [${icuVar}]),`;
    }

    /**
     * Generate a select message entry for the messages file using Intl.select.
     */
    private generateMessageSelectEntry(
        key: string,
        icuVar: string,
        value: string
    ): string {
        const casesStr = this.extractSelectCases(value, icuVar);
        return `    '${key}': (${icuVar}) => Intl.select(${icuVar}, ${casesStr.replace(/\n\s*/g, ' ')}, name: '${key}', args: [${icuVar}]),`;
    }

    private async generateMessagesAll(modules: ParsedModule[]): Promise<void> {
        // FIXED: Namespaced imports and function to avoid Flutter Intl conflict
        const localeImports = this.config.supportedLocales
            .map((l) => `import 'modular_messages_${l}.dart' as modular_messages_${l.replace(/-/g, '_')};`)
            .join('\n');

        const deferredImports = this.config.useDeferredLoading
            ? this.config.supportedLocales
                .map((l) => `import 'modular_messages_${l}.dart' deferred as modular_messages_${l.replace(/-/g, '_')};`)
                .join('\n')
            : '';

        const actualImports = this.config.useDeferredLoading ? deferredImports : localeImports;

        const localeKey = (l: string) => l.replace(/-/g, '_');

        const deferredLibraries = this.config.useDeferredLoading
            ? this.config.supportedLocales
                .map((l) => `  '${l}': () => modular_messages_${localeKey(l)}.loadLibrary(),`)
                .join('\n')
            : this.config.supportedLocales
                .map((l) => `  '${l}': () => Future.value(null),`)
                .join('\n');

        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
// ignore_for_file: non_constant_identifier_names
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

${actualImports}

typedef LibraryLoader = Future<dynamic> Function();

Map<String, LibraryLoader> _deferredLibraries = {
${deferredLibraries}
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
${this.config.supportedLocales.map((l) => `    case '${l}':\n      return modular_messages_${localeKey(l)}.messages;`).join('\n')}
    default:
      return null;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  final actualLocale = Intl.verifiedLocale(
    locale,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}

/// Initialize modular localization messages.
/// Named differently from Flutter Intl's initializeMessages to avoid conflicts.
Future<bool> initializeModularMessages(String localeName) async {
  final availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return false;
  }
  final lib = _deferredLibraries[availableLocale];
  await lib?.call();
  initializeInternalMessageLookup(() => CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return true;
}
`;

        // FIXED: Namespaced filename to avoid conflicts
        const filePath = path.join(this.config.outputPath, 'intl', 'modular_messages_all.dart');
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    private async generateCombinedArbFiles(modules: ParsedModule[]): Promise<void> {
        const arbDir = path.join(this.config.outputPath, 'arb');
        fs.mkdirSync(arbDir, { recursive: true });

        for (const locale of this.config.supportedLocales) {
            const combinedArb: Record<string, unknown> = {
                '@@locale': locale,
                '@@last_modified': new Date().toISOString(),
            };

            for (const module of modules) {
                for (const key of module.keys) {
                    const fullKey = `${module.name}_${key.key}`;
                    combinedArb[fullKey] =
                        key.translations[locale] ||
                        key.translations[this.config.defaultLocale] ||
                        '';

                    if (key.description || key.placeholders) {
                        combinedArb[`@${fullKey}`] = {
                            description: key.description,
                            placeholders: key.placeholders,
                        };
                    }
                }
            }

            const filePath = path.join(arbDir, `modular_l10n_${locale}.arb`);
            fs.writeFileSync(filePath, JSON.stringify(combinedArb, null, 2), 'utf-8');
        }
    }

    private async generateBarrelFile(modules: ParsedModule[]): Promise<void> {
        const exports = [
            `export '${this.toSnakeCase(this.config.className)}.dart';`,
            `export 'app_localization_delegate.dart';`,
            ...modules.map((m) => `export '${this.toSnakeCase(m.name)}_l10n.dart';`),
        ];

        const content = `// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by Modular Flutter L10n Extension
// ignore_for_file: non_constant_identifier_names
${exports.join('\n')}
`;

        const filePath = path.join(this.config.outputPath, 'l10n.dart');
        fs.writeFileSync(filePath, content, 'utf-8');
    }

    // ─── String utilities ────────────────────────────────────────────────

    private toPascalCase(str: string): string {
        return str
            .split(/[_-]/)
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('');
    }

    private toCamelCase(str: string): string {
        const pascal = this.toPascalCase(str);
        return pascal.charAt(0).toLowerCase() + pascal.slice(1);
    }

    private toSnakeCase(str: string): string {
        return str
            .replace(/([a-z])([A-Z])/g, '$1_$2')
            .replace(/[-\s]/g, '_')
            .toLowerCase();
    }

    /**
     * Escape string for Dart string literals.
     * Handles all special characters including $ for string interpolation.
     */
    private escapeDartString(str: string): string {
        return str
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t')
            .replace(/\$/g, '\\\$');
    }

    /**
     * Escape string for Dart doc comments.
     */
    private escapeForDartDoc(str: string): string {
        return str
            .replace(/`/g, "'")
            .replace(/\n/g, ' ')
            .replace(/\r/g, ' ')
            .substring(0, 200);
    }
}